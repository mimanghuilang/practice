#创建型设计模式
* 释义：处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建可能导致设计上的问题或增加设计上的复杂度

## 模式
### 简单工厂模式
优点：
* 工厂和产品的职责区分明确
* 无需知道所创建具体产品的类名，只需知道参数即可
* 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。
缺点：
* 职责过重，一旦异常，整个系统将受影响。
* 工厂类代码会非常臃肿，违背高聚合原则。
* 系统扩展困难，一旦增加新产品不得不修改工厂逻辑

### 工厂方法模式
*将实际创建对象工作推迟到子类当中
优点：
* 简单工厂模式的一个补充,解决了简单工厂模式扩充需要修改工厂函数的情况
* 典型的解耦框架
* 只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程
* 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类
缺点：
* 类的个数容易过多，增加复杂度
* 增加了系统的抽象性和理解难度
* 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

### 抽象工厂模式
*  通过对类的工厂抽象使其业务用于对产品类簇的创建,而不负责某一类产品的实例
优点：
* 拥有工厂方法的优点
* 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
* 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
* 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。
缺点：
* 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

### 建造者模式
* 将一个复杂对象的构建层和表示层相互分离，同样的构建过程可采用不同的表示
* 特点：复合对象
### 原型模式
* 用原型实例指向创建对象的类，使用于创新的对象的类共享原型对象的属性以及方法
### 单例模式
* 又被称为单体模式，是只允许实例化一次的对象类
实现
* 对象字面量
* 字调函数（好处可以有静态变量这样的东西）
惰性单体(延迟创建),自调函数返回一个函数，调用函数返回一个单例



